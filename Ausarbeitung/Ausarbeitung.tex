% Diese Zeile bitte -nicht- aendern.
\documentclass[course=erap]{aspdoc}
\graphicspath{ {./images/} }
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath,amsthm}
\usepackage{amssymb}
\usepackage[font=small,labelfont=bf]{caption}
\newcommand{\uproman}[1]{\uppercase\expandafter{\romannumeral#1}}
\newcommand{\lowroman}[1]{\romannumeral#1\relax}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO: Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte-
%% mit den richtigen Werten.
\newcommand{\theGroup}{142} % Beispiel: 42
\newcommand{\theNumber}{A213} % Beispiel: A123
\author{Anton Baumann \and Felix Brandis \and Michal Cizevskij}
\date{Sommersemester 2020}  % Beispiel: Wintersemester 2019/20
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Diese Zeile bitte -nicht- aendern.
\title{Gruppe \theGroup{} -- Abgabe zu Aufgabe \theNumber}

\usepackage{subfig}

\begin{document}
\maketitle

\section{Einleitung}

Um die in der Vorlesung erlangten Kenntnisse zu vertiefen, wird vom Lehrstuhl für Rechnerarchitektur und Parallele Systeme ein Semester begleitendes Praktikum angeboten.\\
Im Rahmen dieses Rechnerarchitektur Praktikums hat sich unsere Gruppe mit dem Thema der Moore Kurve auseinandergesetzt. Die Moore Kurve ist eine von dem Mathematiker Eliakim Hastings Moore (1862-1932) entwickelte raumfüllende Kurve. Sie basiert auf der Hilbert Kurve und findet oft Anwendung in Bildverarbeitung und Datendarstellung. Unsere erste Aufgabe war es einen Algorithmus in Assembler zu entwickeln, der die Moore Kurve beliebigen Grades erstellt und in einer Datei abbildet. Die zweite Aufgabe war es zu beantworten, ob es möglich ist einen beliebigen Punkt der Kurve in konstanter Zeit unabhängig vom Grad zu berechnen.
\begin{figure}[h]
\centering
    \includegraphics[width=12cm, height=4cm]{Peano}\\ %cite
    \caption{Die drei ersten Iterationen der Peano Kurve}
    \label{fig:Peano}
\end{figure}
Generell ist eine raumfüllenden Kurve (Englisch: space-filling curve oder auch SFC) eine "Linie" die von einem Eindimensionalen Raum auf ein N-Dimensionalen Raum abbildet. Einfachheitshalber beschränken wir uns aber auf zweidimensionalen und ein Beispiel im dreidimensionalen Raum. Die Besonderheit dieser Kurve liegt darin, dass sie jeden Punkt des Einheitsquadrats passiert. Genauer gesagt, wenn n für den Grad der Kurve steht und $\lim_{n\to\infty}$, dann wird eine gegebene Fläche durch so eine Kurve gefüllt.\\
Die erste SFC wurde von einem Italienischen Mathematiker Giuseppe Peano in 1890 entwickelt. (Siehe Abb. \ref{fig:Peano})
\newpage
Die Motivation für solch eine Erkenntnis bekam er durch einen weitern  renommierten Mathematiker Georg Cantor der wenige Jahre zuvor bewiesen hatte, dass die Mengen der natürlichen Zahlen und die der positiven rationalen Zahlen gleich mächtig sind (Cantors erstes diagonal Argument, Abb. \ref{fig:Cantor}). 
Durch das verallgemeinern des Cantorischen Diagonalarguments kann man zeigen, dass es eindimensionale Objekte gibt, \\ die zweidimensionale füllen können. Eine raumfüllende Kurve ist also eine surjektive Abbildung, die von einem Einheitsintervall in ein Einheitsquadrat abbildet.
\begin{figure}[h]
\centering
     \includegraphics[width=5cm, height=5cm]{Cantor}
    \caption{Cantorische Paarungsfunktion}
    \label{fig:Cantor}
\end{figure}
Die Hilbert Kurve, die von dem gleichnamigen Mathematiker David Hilbert in 1891 entwickelt wurde ist eine einfachere Version, die das Einheitsquadrat in 4 Teile anstatt 9 partitioniert. Diese Quadranten beinhalten dann die Hilbert Kurve vom Grad $n - 1$. Betrachtet man zum Beispiel die mittlere Abbildung in Abb. \ref{fig:hilbertCurve}, die Hilbert Kurve zweiten Grades, so bemerkt man, dass sie vier mal die Kurve vom Grad 1 beinhaltet, die rotiert oder gespiegelt wurde und an den End- bzw. Startpunkten verbunden wurden.
\begin{figure}[h]
\centering
   \includegraphics[width=12cm, height=4cm]{Hilbert}
    \caption{Die drei ersten Iterationen der Hilbert Kurve}
    \label{fig:hilbertCurve}
\end{figure}

\newpage %Autor der Moore Kurve ist im Abstract erwähnt fehlt datum leider
Wie bereits erwähnt ist die Moore Kurve eine Variation der Hilbert Kurve. Die ersten Grade der Moore- und Hilbert-Kurve sind äquivalent. Dabei ergeben sich die weiteren Iterationen der Moore Kurve, durch die Zusammensetzung der Hilbert Kurve vom Grad $n - 1$.  Es werden also 4 Kopien der Hilbert Kurve des Grads $n-1$ zur Moore Kurve des Grads $n$ zusammengesetzt (Nach Rotation, Spiegelung und Verschiebung). \textbf{hier noch eine Illustration??}
Entscheidender Unterschied der Moore Kurve zur Hilbert Kurve ist, dass sich ihre Anfangs- und Endpunkte im Gegensatz zur Hilbert Kurve nebeneinander befinden.
\begin{figure}[h]
\centering
      \includegraphics[width=12cm, height=4cm]{Moore}
    \caption{Die drei ersten Iterationen der Moore Kurven}
    \label{fig:mooreCurve}
\end{figure}
Außerdem gehört die Moore Kurve (Peano und Hilbert ebenfalls) einer Unterkategorie der SFC an, die man FASS Kurven nennt. (FASS: „space-filling, self-avoiding, simple and self-similar“).\\
Dies birgt wichtige Eigenschaften, weshalb sie in der Praxis Verwendung findet. Zu einem die Kurve ist selbstausweichend, das bedeutet jeder Punkt ist exakt festgelegt, also wird er nur einmal durchlaufen. Hinzu behält die Kurve die Lokalität der Punkte bei. Das bedeutet, sind die Punkte nah beinander im eindimensionalen Einheitsintervall, so sind sie es ebenfalls in der Kurve. (siehe Abb. \ref{fig:locality}) % http://blog.christianperone.com/2015/08/googles-s2-geometry-on-the-sphere-cells-and-hilbert-curve/
\begin{figure}[h]
\centering
      \includegraphics[width=8cm, height=6cm]{Locality}
    \caption{Graphik um die Eigenschaft der Lokalität zu verdeutlichen} % for spatial DB = raumbezogene Datenbank
    \label{fig:locality}
\end{figure}
In raumbezogenen Anwendungen kommt es oft vor, dass raumfüllende Kurven verwendet werden, um effizient geographische Daten, die in eindimensionaler oder zweidimensionaler Form vorhanden sind, in eindimensionale Daten umzuwandeln. \\Dafür wird das Gebiet in Zellen aufgeteilt. Diese dienen einer kompakten Darstellung der bestimmten Region. Um diese Zellen schnell "ansprechen"' zu können, werden sie indexiert. Dabei ist es erwünscht, dass geographische Nähe, also Nähe in 2 Dimensionen von Bilddaten auch auf der Abbildung in den eindimensionalen Raum erhalten bleibt, da sich so nebeneinander liegende Bilddaten auch nebeneinander im Speicher befinden und effizienter geladen werden können.
Da eine FASS Kurve genau diese Anforderungen erfüllt, eignet sie sich besonders gut für solch eine Verwendung. Ein konkretes Beispiel der Anwendung wäre die \href{https://code.google.com/archive/p/s2-geometry-library/}{S2-geometry-library von Google}. 

% vielleicht noch erwähnen das es alternativen gibt aber zb Hilbert kurve sehr effizient ist
\begin{figure}
    \centering
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{Map}\\
        \caption{Einteilung von New York in Zellen}
        \label{fig:Gmaps}
    \end{minipage}\hfill
    \begin{minipage}{0.45\textwidth}
        \centering
        \includegraphics[width=0.9\textwidth]{Earth} \\
        \caption{Hilbert Kurve projiziert auf die Erde}
        \label{fig:hilbertCurveOnEarth}
    \end{minipage}
\end{figure}

%https://medium.com/sidewalk-talk/s2-cells-and-space-filling-curves-keys-to-building-better-digital-map-tools-for-cities-a312aa5e2f59


%\begin{center}
%   \includegraphics[width=9cm, height=6cm]{Earth}\\    %cite
%   \tiny Abbildung 6: Einteinlung der Erde 
%\end{center}


\section{Lösungsansatz}

\subsection{Die Moore Kurve}

Wie im letzten Abschnitt erwähnt, kann die Moore Kurve des Grads n aus vier Kopien der Hilbert Kurve des Grads n-1 erzeugt werden (für n > 1), siehe dazu auch Abbildung \ref{HilbertZuMoore}.
Das Problem kann also umformuliert werden in die Erzeugung der Hilbert Kurve und dem anschließendenden Kopieren, Verschieben und Rotieren der Punkte. 
\\
Es gibt rekursive Algorithmen für die Erzeugung der Hilbert Kurve, diese klammern wir im Folgenden jedoch aus. (Siehe Aufgabenstellung)

\subsection{Erzeugung der Hilbert Kurve: iterativer Punkt-für-Punkt Ansatz}
Im Folgenden soll ein Algorithmus dargestellt werden, der für gegebenen Index $i$ und Grad $n$ die Koordinaten des korrespondierenden Punktes an der Stelle $i$ der Moore Kurve berechnet.
Geht man davon aus, schon einen solchen funktionierenden Algorithmus für die Hilbert Kurve zu haben, so muss nur der Quadrant des Punktes bestimmt werden, dann der entsprechende Punkt der Hilbert Kurve errechnet und je nach Quadrant verschoben, gespiegelt oder rotiert werden. Dies wird in Abbildung \ref{HilbertZuMoore} grafisch veranschaulicht und im Algorithmus \ref{moore:iterative} skizziert.
\newline
\begin{figure}[h]
\centering
\def\svgwidth{240pt}
\input{images/HilbertZuMooreVektorG.pdf_tex}
\caption{Transformation von Hilbert Kurve des Grads n-1 zu Moore Kurve des Grads n}
\label{HilbertZuMoore}
\end{figure}
\begin{algorithm}[H]
\begin{algorithmic}
\caption{Compute coordinates of point on Moore curve}
\label{moore:iterative}
\Function{computeMooreCoord}{$index$, $degree$}
	\State $len \leftarrow 2^{degree -1}$ \Comment{Half of the sidelength of final curve}
	\State find out quadrant $q$ of point ($q \in \{A, B, C, D\}$)
	\State t$uple \leftarrow$ computeHilbertCoord($index$, $degree-1$)
	\State $tmp \leftarrow tuple.x$
	\If {$q = A$} 
		\Comment{A: rotate 90$^{\circ} \circlearrowleft$}
		\State $tuple.x \leftarrow len - tuple.y - 1$
		\State $tuple.y \leftarrow tmp$
	\ElsIf{$q = B$}
		\Comment{B: rotate 90$^{\circ}\circlearrowleft$ and shift up}
		\State $tuple.x \leftarrow len - tuple.y - 1$
		\State $tuple.y \leftarrow tmp + len$
	\ElsIf{$q = C$}
		\Comment{C: rotate 90$^{\circ}\circlearrowright$ and shift up and right}
		\State $tuple.x \leftarrow tuple.y + len$
		\State $tuple.y \leftarrow 2*len - tmp -1$
	\ElsIf{$q = D$} 
		\Comment{D: rotate 90$^{\circ} \circlearrowright$ and shift right}
		\State $tuple.x \leftarrow tuple.y + len$
		\State $tuple.y \leftarrow len - tmp -1$
	\EndIf
\EndFunction
\Function{computeHilbertCoord}{$index$, $degree$}
	\State [...]
\EndFunction
\end{algorithmic}
\end{algorithm}
Damit Algorithmus \ref{moore:iterative} funktioniert, fehlt noch eine Methode, die für gegebenen Index $i$ und Grad $n$ die Koordinaten des entsprechenden Punktes auf der Hilbert Kurve zurückgibt. Abbildung \ref{fig:hilbertBuildup} zeigt, wie das funktioniert: Jeder Punkt beginnt mit den Koordinatnen $(0, 0)$. Wird der Index in Binärdarstellung umgewandelt, so können von hinten beginnend immer zwei Stellen angesehen werden und dann nach dem in der Graphik dargestellten Entscheidungsmuster die Koordinaten durch Spiegelung und Verschiebung verändert werden. Durch iterative Ausführung und mit jeder Iteration einer Vergrößerung des Offsets können so die Koordinaten jedes Punktes bestimmt werden. Algorithmus \ref{hilbert:iterative} zeigt eine mögliche Formalisierung.

\begin{figure}[H] 
    \centering
    \subfloat{{\includegraphics[width=1.0\textwidth]{HilbertToHilbert} }}%
    \caption{Bottom-up Errechnung der Koordinaten eines Punkts der Hilbert Kurve, Beispiel für Punkt mit Index 54 und HIlbert Kurve des Grads 3}%
    \label{fig:hilbertBuildup}%
\end{figure}


\begin{algorithm}[H]
\begin{algorithmic}
\caption{Compute coordinates of given point on Hilbert curve}
\label{hilbert:iterative}
\Function{computeHilbertCoord}{$index$, $degree$}
	\State $sidelength \leftarrow 2^{degree}$
	\State $i \leftarrow 1$
	\State $coord \leftarrow (0, 0)$
	\While {$i < sidelength$}
		\State find out quadrant $q \in \{A, B, C, D\}$ by looking at last two bits of $index$:
		\State $A \iff '00'$, $B \iff '01'$, $C \iff '10'$, $D \iff '11'$
		\If{$q \in \{A, D\}$}
			\If{$q = D$}
			\State $tmp \leftarrow coord.y$\Comment{mirror along $y = i-1-x$ axis}
			\State $coord.y \leftarrow i - 1 - coord.x$
			\State $coord.x \leftarrow i - 1 - tmp$	
			\Else 
			\State $swap(coord.x, coord.y)$\Comment{mirror along $y=x$ axis}
			\EndIf
		\Else 
		\State $coord.y \leftarrow coord.y + i$ \Comment{translate upwards, because $q \in \{B, C\}$}
		\EndIf
		\If{$q \in \{C, D\}$}
		\State $coord.x \leftarrow coord.x + i$ \Comment{translate to the right}
		\EndIf
		\State $index \leftarrow \frac{index}{4}$ \Comment{shift to the right by two bits to look at next two}
		\State $i \leftarrow 2i$\Comment{sidelength doubles with every iteration}
	\EndWhile
	\State \Return $coord$
\EndFunction
\end{algorithmic}
\end{algorithm}




\subsection{Erzeugung der Hilbert Kurve: Effizienterer Reuse-Ansatz}
Der oben dargestellte Algorithmus hat den Vorteil, für einen gegebenen Index und Grad die Koordinaten des korrespondierenden Punktes ausrechnen zu können, ohne dafür die gesamte Kurve erzeugen zu müssen und dann die Koordinaten an der Stelle des Index auszulesen.\\ 
Soll allerdings die gesamte Kurve erstellt werden, also x-Werte und y-Werte für alle Punkte errechnet werden, so ist der iterative Aufruf des oben gezeigten Algorithmus für jeden Index sehr ineffizient.\\
Ebenso wie die Moore Kurve des Grads $n$ aus vier Kopien der Hilbert Kurve des Grads n aufgebaut werden kann, so kann auch die Hilbert Kurve des Grads n aus vier Kopien der Hilbert Kurve des Grads $n-1$ erzeugt werden (Abbildung \ref{HilbertZuHilbert}).
\begin{figure}[h]
\centering
\def\svgwidth{240pt}
\input{images/HilbertZuHilbertVektorG.pdf_tex}
\caption{Transformation von Hilbert Kurve des Grads n-1 zu Hilbert Kurve des Grads n}
\label{HilbertZuHilbert}
\end{figure}
Man kann also bei der Erzeugung der Hilbert Kurve ähnlich vorgehen wie bei Algorithmus \ref{moore:iterative}: Mit gegebenen Punkten der Hilbert Kurve des Grads $n-1$ lassen sich alle Punkte der Hilbert Kurve des Grads $n$ erzeugen. 
Die Spiegelungen, Rotationen und Translationen für die jeweiligen Quadranten sind natürlich anders als in Algorithmus \ref{moore:iterative}. \\
Dieser Ansatz kann zwar keinen einzelnen Punkt an einem gegebenen Index liefern ohne die gesamte Kurve zu berechnen, andererseits ist dafür die Berechnung aller Punkte der Kurve insgesamt bei weitem effizienter als der iterative Aufruf des Punkt-zu-Punkt Ansatzes, da schon durchgeführte Berechnungen wiederverwertet werden. Algorithmus \ref{moore:batch} zeigt, wie zunächst die Hilbert Kurve bis Grad $n-1$ aufgebaut und daraus dann die Moore Kurve des Grads $n$ erzeugt wird. Für die Nachvollziehbarkeit sind Abbildung \ref{HilbertZuMoore} und \ref{HilbertZuHilbert} essentiell.
\begin{algorithm}[H]
\begin{algorithmic}
\caption{Compute all points of Moore Curve}
\label{moore:batch}
\Function{computeAllMoorePoints}{$degree$, int[] $x$, int[] $y$}
\State hardcode coordinates for $degree =1$ into arrays (each 4 values)
\If {$degree = 1$}
	\Return
\EndIf	
\State computeAllHilbertPoints($degree - 1$, int[] $x$, int[] $y$)
\State $i \leftarrow 0$
\State $len \leftarrow 2^{degree - 1} -1$ \Comment{offset for translation}
\State $quarter \leftarrow 4^{degree-1}$\Comment{sidelength of hilbert curve squared $= {(2^{degree - 1}})^2$}
\While {$i < quarter$}
\\ \Comment{quadrant B: rotate A 90$^{\circ}\circlearrowleft$ and shift up}
\State $x[i + quarter] \leftarrow len - y[i]$
\State $y[i + quarter] \leftarrow x[i] + len + 1$
\\ \Comment{quadrant C: rotate A 90$^{\circ}\circlearrowright$ and shift up and right}
\State $x[i + 2*quarter] \leftarrow y[i] + len + 1$
\State $y[i + 2*quarter] \leftarrow 2 * len - x[i] + 1$
\\ \Comment{quadrant D: copy C and shift down}
\State $x[i + 3*quarter] \leftarrow x[i + 2*quarter]$
\State $y[i + 3*quarter] \leftarrow y[i + 2*quarter] - len - 1$
\\ \Comment{quadrant A: copy B and shift down}
\State $x[i] \leftarrow x[i + quarter]$
\State $y[i] \leftarrow y[i + quarter] - len - 1$
\\
\State $i \leftarrow i+1$
\EndWhile
\EndFunction


\Function{computeAllHilbertPoints}{$degree$, int[] $x$, int[] $y$}

\State $j \leftarrow 2$\Comment{we start buildup from degree 2, as degree 1 is hardcoded}
\State $len \leftarrow 2$ \Comment{offset starts at 2}
\State $quarter \leftarrow 4$\Comment{we begin with 4 points which are hardcoded}
\While{$j \leq degree$}
\While {$i < quarter$}
\\ \Comment{quadrant B: shift up A}
\State $x[i + quarter] \leftarrow x[i]$
\State $y[i + quarter] \leftarrow y[i] + len$
\\ \Comment{quadrant A: mirror along the line $x=y$}
\State swap($x[i], y[i]$)
\\ \Comment{quadrant C: copy B and shift right}
\State $x[i + 2*quarter] \leftarrow x[i + quarter] + len$
\State $y[i + 2*quarter] \leftarrow y[i + quarter]$
\\ \Comment{quadrant D: rotate A 180$^{\circ}$ and shift right}
\State $x[i + 3*quarter] \leftarrow 2*len - 1 - x[i]$
\State $y[i + 3*quarter] \leftarrow len - 1 - y[i]$
\\

\EndWhile
\State $i \leftarrow i+1$
\State $len \leftarrow 2*len$\Comment{with every iteration, the sidelength doubles...}
\State $quarter \leftarrow 4*quarter$\Comment{ ...and the amount of points quadruples}
\EndWhile
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Theoretische Laufzeitanalyse und Vergleich}
Für Algorithmus \ref{hilbert:iterative} lässt sich schnell sehen, dass der Aufwand für die Berechnung eines Punkts vom Grad der Kurve abhängt: In der computeHilberCoord($index, degree$) Unterfunktion wird eine Schleife $log_2(2^{degree})-1 = degree -1$ mal durchlaufen. Da der Aufwand der Operationen innerhalb der Schleife konstant ist, steigt der Aufwand für die Berechnung eines einzelnen Punkts bei Algorithmus \ref{hilbert:iterative} also linear mit dem Grad der Kurve.
\newline
Für Algorithmus \ref{moore:batch} lässt sich zeigen, dass der durschnittliche Aufwand für die Berechnung eines Punktes konstant ist, unabhängig vom Grad der Kurve. \\
Algorithmus \ref{moore:batch} besteht aus dem einmaligen Aufruf der Hilbert-Unterfunktion und dann dem Verschieben der erhaltenen Punkte zur Erzeugung der Moore Kurve. \\
In der Hilbert Unterfunktion gibt es zwei ineinander verschachtelte Schleifen: eine, die die Indexvariable $j$ von $2$ bis inklusiv  $degree -1$ durchläuft (Denn die Hilbert Unterfunktion wird ja mit $degree-1$ aufgerufen) und die innere Schleife, bei der die Punkte des letzten Grades kopiert und verschoben werden. \\ 
Diese innere Schleife wird $quarter = 4^{j-1}$ mal durchlaufen, denn es müssen immer alle Punkte der Kurve des Grads $j-1$ kopiert und verschoben werden. Diese innere Schleife hat konstanten Aufwand $c$. In ihr wird ein Punkt aus dem Speicher  geladen, die Koordinaten werden manipuliert und an 4 Stellen wieder in den Speicher geschrieben. (Die Annahme der Konstanz ist hier natürlich theoretisch: sie berücksichtigt keine Zeitunterschiede durch Caching oder RAM-Limits, sondern geht von einem idealisierten Maschinenmodell ohne die Probleme des Von-Neumann-Bottlenecks aus)\\
Nach Durchlaufen der Hilbert Unterfunktion werden in der Moore Funktion dann noch einmal  $4^{degree-1}$ Punkte kopiert und verschoben. \\ Der Aufwand für die Berechnung der Punkte der Moore Kurve des Grads n $Op(n)$ kann also folgendermaßen rekursiv definiert werden: \ \\
\[\uproman{1}: Op(n) = Op(n-1) + 4^{n-1}*\cdot\]
\[\uproman{2}: Op(1) = c\] \ \\ 
Diese rekursive Gleichung kann nun aufgelöst werden:  \ \\ 
\begin{align*}
  Op(n) &= Op(n-1) + 4^{n-1}\cdot c\\
    &= Op(n-2) + 4^{n-2}\cdot c + 4^{n-1}\cdot c \\
    &= c\cdot(4^{0} + ... + 4^{n-2} + 4^{n-1}) \\
    &= c\cdot\sum_{i=0}^{n-1} 4^{i}\\
    &= c\cdot\frac{1}{3}(4^n-1)\\
\end{align*}
Eine Kurve von Grad $n$ hat Seitenlänge $2^n$ und somit $4^n$ Punkte. Der durchschnittliche Aufwand pro Punkt $avg\_Cost(n)$ lässt sich also wie folgt berechnen: \ \\
\[avg\_Cost(n) = \frac{Op(n)}{4^n} = c \cdot \left(\frac{4^n}{3 \cdot 4^n} - \frac{1}{3 \cdot 4^n}\right) = \frac{1}{3}c - c \cdot \frac{1}{3 \cdot 4^n}\] 
\[\Rightarrow \lim_{n\to\infty} avg\_Cost(n) = \lim_{n\to\infty} \frac{Op(n)}{4^n} = \frac{1}{3}c\]  \ \\ 
Der durchschnittliche Rechenaufwand pro Punkt konvergiert also zu einem konstanten Wert. Das heißt, dass sich der absolute Aufwand bei Erhöhung des Grads um eins ungefähr um den Faktor vier erhöht, der durchschnittliche Aufwand pro Punkt aber gleich bleibt, da sich die Anzahl der Punkte mit Erhöhung des Grads ebenso vervierfacht.

% TODO: Je nach Aufgabenstellung einen der Begriffe wählen
\section{Korrektheit}
Im Gegensatz zu Aufgabenstellungen, die Floating-Point Berechnungen enthalten oder im Bereich der Kryptographie liegen, ist in unserem Fall eine Überprüfung der Korrektheit unserer Lösung zumindest in Graden <10 allein schon durch das Betrachten der visuellen Repräsentation der Koordinaten im vom Rahmenprogramm erzeugten .svg File möglich. Dass unser Lösung korrekt ist, zeigen außerdem die oben dargelegten Algorithmen, die theoretisch für beliebige $n>0$ funktionieren.

%Ist das zu dreist???


\section{Performanzanalyse}
Um das Laufzeitzeitverhalten unserer Implementierung der Moore-Kurve zu überprüfen und beurteilen, haben wir Benchmarks folgender vier Implementierungen auf einem MaxBook Pro mit einem 3,1 Ghz Dual-Core Intel i7 und 16 Gb 1867 Mhz DDR3 RAM durchgeführt.

\begin{center}
    \begin{tabular}{| r | r | r | r | r | r | r |}
    \hline
    Grad \textit{n} & \# Punkte & Speicher & \textit{asm\_avx} & \textit{asm} & \textit{c\_batch} & \textit{c\_iter}  \\ \hline
    3 & 64 & 512 B  & 27 ns & 23 ns & 67 ns & 1796 ns \\  \hline
    6 & 4096 & 32 KiB  & 601 ns & 1213 ns & 6524 ns & 219 $\mu s$ \\  \hline
    9 & 26144 & 2048 KiB  & 179 $\mu s$ & 289 $\mu s$ & 830 $\mu s$ & 16562 $\mu s$  \\  \hline
    12 & 16,78 * 1e6 & 128 MiB & 21,5 ms & 24,5 ms & 94,3 ms & 1303,1 ms \\ \hline
    15 & 1,07 * 1e9 & 8 GiB & 1575,9 ms & 1607,4 ms & 7108,1 ms & 92985,2 ms \\ \hline
    16 & 4,29 * 1e9 & 32 GiB & 108,3 s & 125,7 s & 175,9 s & 718,1 s \\ \hline
    \end{tabular}
\end{center}

\begin{figure}[htbp] 
    \centering
    \subfloat[alle Implementierungen]{{\includegraphics[width=0.45\textwidth]{laufzeitvergleich_1-6_alle_impl.png} }}%
    \qquad
    \subfloat[ohne \textit{c\_iter}]{{\includegraphics[width=0.45\textwidth]{laufzeitvergleich_1-6_fast.png} }}%
    \caption{Laufzeitverhalten der vier Implementierungen bis Grad 6}%
    \label{fig:Laufzeitvergleich}%
 \end{figure}
 
 \subsection{Iterative Berechnung der Moore-Koordinaten}
Aus Abb. 1 geht klar hervor, dass die iterative Berechnung der Moore-Koordinaten (wie in Sektion 2 beschrieben) deutlich ineffizienter ist als die anderen Implementierungen. Ein Vorteil dieser Variante ist zwar, dass sie nur sehr wenige Speicherzugriffe benötigt, da alle Berechnungen in den Registern durchgeführt werden können und nur das Endergebnis in den Speicher geschrieben wird. Durch das rein iterative Vorgehen kann dieser Algorithmus jedoch nicht sinnvoll auf Datenebene parallelisiert werden. Auch kann der dynamische Ansatz, von dem die übrigen Implementierungen profitieren, hier nicht angewandt werden. Im folgenden liegt daher der Fokus auf den restlichen Implementierungen.

\subsection{Vergleich Assembler- mit Referenzprogramm}
Die Implementierungen \textit{c\_ batch}, \textit{asm\_avx} und \textit{asm} ... siehe Section 3 ... \newline
An Abb. 1.b und den Benchmarkwerten kann man erkennen, dass die Assembler Implementierungen deutlich performanter sind als die C-Referenzimplementierung. Für Grad 6 ist die Assembler-Implementierung, welche 128-bit Register benutzt, drei mal schneller als das C-Programm. Dies ist darin begründet, dass sich die dynamische Berechnung der Hilberkurve optimal durch SIMD parallelisieren lässt. Somit können einige Koordinaten gleichzeitig innerhalb einer Operation verarbeitet werden. Die Anzahl der Punkte, die in ein SIMD-Register passen ist abhängig vom Datentypen der Koodinaten und der Größe der Vektorregister. Wir haben uns entschieden, von der in der Aufgabenstellung vorgegebenen Signatur \texttt{moore(uint64\_t degree, uint64\_t *x, uint64\_t *y)} abzuweichen und 32 bit Integer zu benutzen. Der maximale darstellbare Wert verringert sich dadurch zwar auf $2^{32}-1$, jedoch werden größere Werte erst ab einem $n > 32$ benötigt. Der Speicherbedarf einer Moore Kurve mit Grad 33 betrüge $4^{33} \cdot 2 \cdot 4 \text{ Bytes } \approx 590 \cdot 10^{18} \text{ Bytes}$, wenn man alle Koordinaten als 32 bit unsigned Integers darstellen könnte und das Doppelte bei Benutzung von 64 bit Integern. 
\newline
Durch die Reduzierung auf 32 bit Intger können nun bei Verwenung von 128 bit Vektorregistern vier und bei 258 bit Registern acht Werte gleichzeitig verarbeitet werden (siehe Abb. 2).

\begin{figure}[htbp] 
    \centering
    \subfloat{{\includegraphics[width=0.69\textwidth]{hilbert_transformation.png} }}%
    \caption{Parallelisierung durch SIMD}%
    \label{fig:SIMD}%
\end{figure}

Durch Disassemblieren der mit \texttt{-march=native -O3} kompilierten Binärdatei festgestellt haben, dass der Compiler den C Code nicht vektorisiert. Daher war unsere anfängliche Vermutung, dass \textit{asm\_128} etwa vier mal so schnell ist wie unsere C-Implementierung und \textit{asm\_256} in der Hälfte der Zeit von \textit{asm\_128} terminiert.

\begin{figure}[htbp] 
    \centering
    \subfloat[Speedup Assembler- ggü. C-Implementierung]{{\includegraphics[width=0.45\textwidth]{speedup_base_c.png} }}%
    \qquad
    \subfloat[Speedup \textit{asm\_256} ggü. \textit{asm\_128}]{{\includegraphics[width=0.45\textwidth]{speedup_base_asm_128.png} }}%
    \caption{Laufzeitvergleich C/ASM}%
    \label{fig:Laufzeitvergleich}%
 \end{figure}
 
 Abb. 3.a bestätigt den ersten Teil unserer Vermutung. Zwischen Grad 4 und 15 ist die \textit{asm\_128} Implementierung 2,8 bis 5,3 mal schneller als die Referenzimplementierung in C. Der zweite Teil trifft nur teilweise zu. Wie in Abb. 3.b zu sehen ist, profitieren vor allem Grade zwischen 6 und 10 von den größeren Vektorregistern. Bei größeren Graden bietet die Verwendung von AVX-Registern keine signifikante Performanzsteigerung.
 
\subsection{Cache Effizienz}
Abb 3.a wirft die Frage auf, weshalb die Assembler Implementierug bei Grad 6 besonders performant ist. Dies lässt sich vermutlich damit beantworten, dass die Moore Kurve sechsten Grades genau \textit{32 KiB} an Speicher benötigt und die Größe des L1 Caches der Maschine auf der getestet wurde \textit{32 KiB} beträgt. Um diese Annahme zu überprüfen wurde das Programm mit dem MacOS Tool \textit{Instruments} auf Cache-Misses (insbesondere L1) überprüft, mit dem Ergebnis, dass 6 der höchste Grad ist, bei dem noch nahezu keine L1 Misses auftreten.

\begin{figure}[htbp] 
    \centering
    \subfloat[Grad 1 - 15]{{\includegraphics[width=0.45\textwidth]{ns_per_coord_1-15.png} }}%
    \qquad
    \subfloat[Grad 1 - 16]{{\includegraphics[width=0.45\textwidth]{ns_per_coord_1-16.png} }}%
    \caption{Nanosekunden pro Punkt der Moore Kurve}%
    \label{fig:Laufzeitvergleich Skaliert}%
 \end{figure}
 
 Der Vollständigkeit halber muss noch der Effizienzeinbruch bei Grad 16 angesprochen werden. Dieser ist damit zu erklären, dass die Speicheranforderung für die Berechnung der Moore Kurve auf 32GiB steigt. Da unser Computer nur 16 GiB an Arbeitsspeicher zur Verfügung stellt, müssen nun häufig Speicherseiten auf die Festplatte ausgelagert werden, was zu starken Performanzeinbußen führt.



\section{Zusammenfassung und Ausblick}

% TODO: Fuegen Sie Ihre Quellen der Datei Ausarbeitung.bib hinzu
% Referenzieren Sie diese dann mit \cite{}.
% Beispiel: CR2 ist ein Register der x86-Architektur~\cite{intel2017man}.
\bibliographystyle{plain}
\bibliography{Ausarbeitung}{}

\end{document}
